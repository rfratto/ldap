// Package ldif contains a basic LDIF parser (RFC 2849). This one currently
// just supports LDIFs like they are generated by tools like ldapsearch(1)
// slapcat(8). Change records are not supported while unmarshalling.
// For marshalling support for mod(r)dn is missing.
//
// Controls are not supported in both modes.
//
// URL schemes in an LDIF like
//   jpegPhoto;binary:< file:///usr/share/photos/someone.jpg
// are only supported for the "file" scheme like in the example above
package ldif

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"errors"
	"fmt"
	"gopkg.in/ldap.v2"
	"io"
	"io/ioutil"
	"net/url"
	// "os"
	"strconv"
	"strings"
)

// Entry is one entry in the LDIF
type Entry struct {
	Entry  *ldap.Entry
	Add    *ldap.AddRequest
	Del    *ldap.DelRequest
	Modify *ldap.ModifyRequest
	//ModDN  *ldap.ModifyDNRequest
}

// The LDIF struct is used for parsing an LDIF
type LDIF struct {
	Entries    []*Entry
	Version    int
	changeType string
	FoldWidth  int
}

// The ParseError holds the error message and the line in the ldif
// where the error occurred.
type ParseError struct {
	Line    int
	Message string
}

// Error implements the error interface
func (e *ParseError) Error() string {
	return fmt.Sprintf("Error in line %d: %s", e.Line, e.Message)
}

var cr byte = '\x0D'
var lf byte = '\x0A'
var sep = string([]byte{cr, lf})
var comment byte = '#'
var space byte = ' '
var spaces = string(space)

// Parse wraps Unmarshal to parse an LDIF from a string
func Parse(str string) (l *LDIF, err error) {
	buf := bytes.NewBuffer([]byte(str))
	l = &LDIF{}
	err = Unmarshal(buf, l)
	return
}

// Unmarshal parses the LDIF from the given io.Reader into the LDIF struct.
// The caller is responsible for closing the io.Reader if that is
// needed.
func Unmarshal(r io.Reader, l *LDIF) (err error) {
	if r == nil {
		return &ParseError{Line: 0, Message: "No reader present"}
	}
	curLine := 0
	l.Version = 0
	l.changeType = ""
	isComment := false

	reader := bufio.NewReader(r)

	var lines []string
	var line, nextLine string

	for {
		curLine++
		nextLine, err = reader.ReadString(lf)
		nextLine = strings.TrimRight(nextLine, sep)

		switch err {
		case nil, io.EOF:
			switch len(nextLine) {
			case 0:
				if len(line) == 0 && err == io.EOF {
					return nil
				}
				lines = append(lines, line)
				entry, perr := l.parseEntry(lines)
				if perr != nil {
					return &ParseError{Line: curLine, Message: perr.Error()}
				}
				l.Entries = append(l.Entries, entry)
				line = ""
				lines = []string{}
				if err == io.EOF {
					return nil
				}
			default:
				switch nextLine[0] {
				case comment:
					isComment = true
					continue

				case space:
					if isComment {
						continue
					}
					line += nextLine[1:]
					continue

				default:
					isComment = false
					if len(line) != 0 {
						lines = append(lines, line)
					}
					line = nextLine
					continue
				}
			}
		default:
			return &ParseError{Line: curLine, Message: err.Error()}
		}
	}
}

func (l *LDIF) parseEntry(lines []string) (entry *Entry, err error) {
	if len(lines) == 0 {
		return nil, errors.New("empty entry?")
	}

	if l.Version == 0 && strings.HasPrefix(lines[0], "version:") {
		line := strings.TrimLeft(lines[0][8:], spaces)
		if l.Version, err = strconv.Atoi(line); err != nil {
			return nil, err
		}

		if l.Version != 1 {
			return nil, errors.New("Invalid version spec " + string(line))
		}

		l.Version = 1
		if len(lines) == 1 {
			return nil, nil
		}
		lines = lines[1:]
	}

	if len(lines) == 0 {
		return nil, nil
	}

	if !strings.HasPrefix(lines[0], "dn:") {
		return nil, errors.New("Missing dn:")
	}
	_, val, err := l.parseLine(lines[0])
	if err != nil {
		return nil, err
	}
	dn := val

	if len(lines) == 1 {
		return nil, errors.New("only a dn: line")
	}

	lines = lines[1:]
	if strings.HasPrefix(lines[0], "changetype:") {
		_, val, err := l.parseLine(lines[0])
		if err != nil {
			return nil, err
		}
		l.changeType = val
		if len(lines) > 1 {
			lines = lines[1:]
		}
	}
	switch l.changeType {
	case "":
		attrs, err := l.parseAttrs(lines)
		if err != nil {
			return nil, err
		}
		return &Entry{Entry: ldap.NewEntry(dn, attrs)}, nil

	case "add":
		attrs, err := l.parseAttrs(lines)
		if err != nil {
			return nil, err
		}
		add := ldap.NewAddRequest(dn)
		for attr, vals := range attrs {
			add.Attribute(attr, vals)
		}
		return &Entry{Add: add}, nil

	case "delete":
		if len(lines) > 0 {
			return nil, errors.New("no attributes allowed for changetype delete")
		}
		return &Entry{Del: ldap.NewDelRequest(dn, nil)}, nil

	case "modify":
		mod := ldap.NewModifyRequest(dn)
		var op, attribute string
		var values []string
		if lines[len(lines)-1] != "-" {
			return nil, errors.New("modify request does not close with a single dash")
		}

		for i := 0; i < len(lines); i++ {
			if lines[i] == "-" {
				switch op {
				case "":
					return nil, fmt.Errorf("empty operation")
				case "add":
					mod.Add(attribute, values)
				case "replace":
					mod.Replace(attribute, values)
				case "delete":
					mod.Delete(attribute, values)
				default:
					return nil, fmt.Errorf("invalid operation %s in modify request", op)
				}
			}
			attr, val, err := l.parseLine(lines[i])
			if err != nil {
				return nil, err
			}
			if op == "" {
				op = attr
				attribute = val
			} else {
				if attr != attribute {
					return nil, fmt.Errorf("invalid attribute %s in %s request for %s", attr, op, attribute)
				}
			}
		}
		return &Entry{Modify: mod}, nil

	case "moddn", "modrdn":
		return nil, fmt.Errorf("unsupported changetype %s", l.changeType)
		/*
		   attrs, err := l.parseAttrs(lines)
		   var newRDN, newSuperior string
		   if err != nil{
		       return nil, err
		   }
		   num := 0
		   delOld := false
		   d, ok := attrs["deleteoldrdn"]
		   if ok {
		       num++
		       if len(d) != 1 {
		           return nil, errors.New("too many deleteoldrdn attrs")
		       }
		       switch d[0] {
		       case "1":
		           delOld = true
		       case "0":
		           delOld = false
		       default:
		           return nil, errors.New("invalid value for deleteoldrdn attribute")
		       }
		   }
		   rdn, ok := attrs["newrdn"]
		   if ok  {
		       if len(rdn) != 1 {
		           return nil, errors.New("too many newrdn attrs")
		       }
		       newRDN = rdn[0]
		       num++
		   }
		   newSup, ok := attrs["newsuperior"]
		   if ok {
		       if len(newSup) != 1 {
		           return nil, errors.New("too many newsuperior attrs")
		       }
		       newSuperior = newSup[0]
		       num++
		   }
		   if len(attrs) > num {
		       return nil, fmt.Errorf("extra attributes for %s", l.changeType)
		   }
		   return &Entry{
		       ModifyDN: &ldap.ModifyDNRequest{
		           DN: dn,
		           NewRDN: newRDN,
		           DeleteOldRDN: delOld,
		           NewSuperior: newSuperior,
		       },
		   }, nil
		*/
	default:
		return nil, fmt.Errorf("invalid changetype %s", l.changeType)
	}
}

func (l *LDIF) parseAttrs(lines []string) (map[string][]string, error) {
	attrs := make(map[string][]string)
	for i := 0; i < len(lines); i++ {
		attr, val, err := l.parseLine(lines[i])
		if err != nil {
			return nil, err
		}
		attrs[attr] = append(attrs[attr], val)
	}
	return attrs, nil
}

func (l *LDIF) parseLine(line string) (attr, val string, err error) {
	off := 0
	for len(line) > off && line[off] != ':' {
		off++
		if off >= len(line) {
			err = errors.New("Missing : in line")
			return
		}
	}
	if off == len(line) {
		err = errors.New("Missing : in line")
		return
	}

	if off > len(line)-2 {
		err = errors.New("empty value")
		// FIXME: this is allowed for some attributes
		return
	}

	attr = line[0:off]
	if err = validAttr(attr); err != nil {
		attr = ""
		val = ""
		return
	}

	switch line[off+1] {
	case ':':
		var n int
		value := strings.TrimLeft(line[off+2:], spaces)
		dec := make([]byte, base64.StdEncoding.DecodedLen(len([]byte(value))))
		n, err = base64.StdEncoding.Decode(dec, []byte(value))
		if err != nil {
			return
		}
		val = string(dec[:n])

	case '<':
		var u *url.URL
		var data []byte
		val = strings.TrimLeft(line[off+2:], spaces)
		u, err = url.Parse(val)
		if err != nil {
			err = fmt.Errorf("failed to parse URL: %s", err)
			return
		}
		if u.Scheme != "file" {
			err = fmt.Errorf("unsupported URL scheme %s", u.Scheme)
			return
		}
		data, err = ioutil.ReadFile(u.Path)
		if err != nil {
			err = fmt.Errorf("failed to read %s: %s", u.Path, err)
			return
		}
		val = string(data) // FIXME: safe?

	default:
		val = strings.TrimLeft(line[off+1:], spaces)
	}

	return
}

func validOID(oid string) error {
	lastDot := true
	for _, c := range oid {
		switch {
		case c == '.' && lastDot:
			return errors.New("OID with at least 2 consecutive dots")
		case c == '.':
			lastDot = true
		case c >= '0' && c <= '9':
			lastDot = false
		default:
			return errors.New("Invalid character in OID")
		}
	}
	return nil
}

func validAttr(attr string) error {
	if len(attr) == 0 {
		return errors.New("empty attribute name")
	}
	switch {
	case attr[0] >= 'A' && attr[0] <= 'Z':
		// A-Z
	case attr[0] >= 'a' && attr[0] <= 'z':
		// a-z
	default:
		if attr[0] >= '0' && attr[0] <= '9' {
			return validOID(attr)
		}
		return errors.New("invalid first character in attribute")
	}
	for i := 1; i < len(attr); i++ {
		c := attr[i]
		switch {
		case c >= '0' && c <= '9':
		case c >= 'A' && c <= 'Z':
		case c >= 'a' && c <= 'z':
		case c == '-':
		case c == ';':
		default:
			return errors.New("invalid character in attribute name")
		}
	}
	return nil
}

// AllEntries returns all *ldap.Entries in the LDIF
func (l *LDIF) AllEntries() (entries []*ldap.Entry) {
	for _, entry := range l.Entries {
		if entry.Entry != nil {
			entries = append(entries, entry.Entry)
		}
	}
	return entries
}
